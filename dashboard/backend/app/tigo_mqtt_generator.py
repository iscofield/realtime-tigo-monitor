"""Tigo-MQTT configuration generator (Phase 1 spec FR-2).

Generates deployment files for tigo-mqtt service:
- docker-compose.yml
- config-{cca_name}.ini for each CCA
- .env.example
- README.md with deployment instructions
- ZIP archive containing all files
"""

import io
import logging
import zipfile
from typing import Optional

import yaml

from .config_models import (
    SystemConfig,
    CCAConfig,
    MQTTConfig,
    Panel,
    parse_tigo_label,
)

logger = logging.getLogger(__name__)


class TigoMQTTGeneratorError(Exception):
    """Error during tigo-mqtt config generation."""
    pass


def generate_docker_compose(system_config: SystemConfig) -> str:
    """Generate docker-compose.yml for tigo-mqtt deployment (FR-2.1).

    Args:
        system_config: System configuration with CCAs defined

    Returns:
        YAML string for docker-compose.yml
    """
    services = {}

    for cca in system_config.ccas:
        service_name = f"taptap-{cca.name}"
        services[service_name] = {
            "build": ".",
            "container_name": service_name,
            "restart": "unless-stopped",
            "network_mode": "host",
            "mem_limit": "256m",
            "group_add": ["dialout"],
            "env_file": [".env"],
            "devices": [f"{cca.serial_device}:{cca.serial_device}"],
            "volumes": [
                f"./config-{cca.name}.ini:/app/config-template.ini:ro",
                f"./data/{cca.name}:/data",
                f"./run/{cca.name}:/run/taptap"
            ],
            "logging": {
                "driver": "json-file",
                "options": {
                    "max-size": "10m",
                    "max-file": "3"
                }
            },
            "healthcheck": {
                "test": [
                    "CMD", "sh", "-c",
                    "test -f /run/taptap/taptap.run && "
                    "find /run/taptap/taptap.run -mmin -1 | grep -q ."
                ],
                "interval": "60s",
                "timeout": "10s",
                "retries": 3,
                "start_period": "120s"
            }
        }

    compose = {"services": services}

    # Use custom representer to get cleaner YAML output
    return yaml.dump(compose, default_flow_style=False, sort_keys=False)


def generate_ini_config(
    cca: CCAConfig,
    panels: list[Panel],
    mqtt: MQTTConfig
) -> str:
    """Generate config-{name}.ini for a single CCA (FR-2.2).

    Args:
        cca: CCA configuration
        panels: List of panels (filtered to this CCA)
        mqtt: MQTT configuration

    Returns:
        INI file content as string

    Raises:
        TigoMQTTGeneratorError: If CCA has no panels or label parsing fails
    """
    # Build MODULES line from panels
    modules = []
    for panel in panels:
        if panel.cca == cca.name:
            # Format: STRING:POSITION:SERIAL
            parsed = parse_tigo_label(panel.tigo_label)
            if parsed is None:
                raise TigoMQTTGeneratorError(
                    f"Invalid tigo_label format: {panel.tigo_label}"
                )
            string_name, position = parsed
            modules.append(f"{string_name}:{position}:{panel.serial}")

    if not modules:
        raise TigoMQTTGeneratorError(
            f"CCA '{cca.name}' has no panels configured. "
            "Each CCA must have at least one panel."
        )

    modules_line = ",".join(modules)

    return f"""# TapTap-MQTT Configuration - {cca.name.title()} CCA
# Generated by Solar Tigo Viewer Setup Wizard
# Credentials are injected via environment variables at startup

[MQTT]
SERVER = ${{MQTT_SERVER}}
PORT = ${{MQTT_PORT}}
USER = ${{MQTT_USER}}
PASS = ${{MQTT_PASS}}
QOS = 1
TIMEOUT = 30

[TAPTAP]
LOG_LEVEL = info
BINARY = /usr/local/bin/taptap
SERIAL = {cca.serial_device}
ADDRESS =
PORT = 502
MODULES = {modules_line}
TOPIC_PREFIX = taptap
TOPIC_NAME = {cca.name}
TIMEOUT = 300
UPDATE = 5
STATE_FILE = /data/taptap.state

[HA]
DISCOVERY_PREFIX = homeassistant
DISCOVERY_LEGACY = false
BIRTH_TOPIC = homeassistant/status
NODES_AVAILABILITY_ONLINE = true
NODES_AVAILABILITY_IDENTIFIED = true
STRINGS_AVAILABILITY_ONLINE = true
STRINGS_AVAILABILITY_IDENTIFIED = true
STATS_AVAILABILITY_ONLINE = true
STATS_AVAILABILITY_IDENTIFIED = true
NODES_SENSORS_RECORDER = energy
STRINGS_SENSORS_RECORDER = energy_daily
STATS_SENSORS_RECORDER = energy_daily

[RUNTIME]
MAX_ERROR = 15
RUN_FILE = /run/taptap/taptap.run
"""


def generate_env_example(mqtt: MQTTConfig) -> str:
    """Generate .env.example file (FR-2.3).

    Args:
        mqtt: MQTT configuration (used for defaults/hints)

    Returns:
        .env.example file content
    """
    return f"""# MQTT Broker Configuration
# Copy this file to .env and fill in your credentials

MQTT_SERVER={mqtt.server}
MQTT_PORT={mqtt.port}
MQTT_USER={mqtt.username or 'your_mqtt_username'}
MQTT_PASS={mqtt.password or 'your_mqtt_password'}
"""


def generate_readme(system_config: SystemConfig) -> str:
    """Generate README.md with deployment instructions.

    Args:
        system_config: System configuration

    Returns:
        README.md content
    """
    cca_names = [cca.name for cca in system_config.ccas]
    cca_list = "\n".join(f"- `taptap-{name}`" for name in cca_names)
    config_list = "\n".join(f"- `config-{name}.ini`" for name in cca_names)

    return f"""# Tigo-MQTT Deployment Configuration

This archive contains configuration files for deploying the tigo-mqtt service
on your Raspberry Pi.

## Generated Configuration

**Services:**
{cca_list}

**Config Files:**
{config_list}

## Deployment Instructions

### 1. Clone the tigo-mqtt repository

On your Raspberry Pi:

```bash
git clone https://github.com/your-org/tigo-mqtt.git
cd tigo-mqtt
```

### 2. Copy generated configuration files

Extract this ZIP and copy the files to your tigo-mqtt directory:

```bash
# Copy docker-compose.yml (overwrites existing)
cp docker-compose.yml /path/to/tigo-mqtt/

# Copy INI config files
cp config-*.ini /path/to/tigo-mqtt/

# Copy and configure environment file
cp .env.example /path/to/tigo-mqtt/.env
```

### 3. Configure credentials

Edit the `.env` file with your MQTT broker credentials:

```bash
nano .env
```

### 4. Create data directories

```bash
mkdir -p data/{{{",".join(cca_names)}}}
mkdir -p run/{{{",".join(cca_names)}}}
```

### 5. Build and start the services

```bash
docker compose build
docker compose up -d
```

### 6. Verify the services are running

```bash
docker compose ps
docker compose logs -f
```

### 7. Return to the setup wizard

Once the services are running and publishing data to MQTT, return to the
Solar Tigo Viewer setup wizard to continue with panel discovery.

## Troubleshooting

### Services won't start

- Check serial device paths: `ls -la /dev/ttyACM*`
- Verify user is in dialout group: `groups`
- Check Docker logs: `docker compose logs taptap-{cca_names[0]}`

### No MQTT data

- Verify MQTT broker is reachable: `mosquitto_pub -h {system_config.mqtt.server} -t test -m test`
- Check credentials in `.env` file
- Look for connection errors in logs

## Configuration Reference

- MQTT Server: `{system_config.mqtt.server}`
- MQTT Port: `{system_config.mqtt.port}`
- Topic Prefix: `taptap`

Generated by Solar Tigo Viewer Setup Wizard
"""


def generate_tigo_mqtt_zip(
    system_config: SystemConfig,
    panels: Optional[list[Panel]] = None
) -> bytes:
    """Generate ZIP archive with all tigo-mqtt deployment files (FR-2.4).

    Args:
        system_config: System configuration
        panels: Panel list (may be empty for initial setup)

    Returns:
        ZIP file content as bytes
    """
    panels = panels or []

    # Create in-memory ZIP file
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
        # docker-compose.yml
        compose_content = generate_docker_compose(system_config)
        zf.writestr("docker-compose.yml", compose_content)

        # config-{name}.ini for each CCA
        for cca in system_config.ccas:
            try:
                ini_content = generate_ini_config(cca, panels, system_config.mqtt)
                zf.writestr(f"config-{cca.name}.ini", ini_content)
            except TigoMQTTGeneratorError as e:
                # If no panels yet, generate placeholder INI
                logger.warning(f"Generating placeholder INI for {cca.name}: {e}")
                placeholder = generate_placeholder_ini(cca, system_config.mqtt)
                zf.writestr(f"config-{cca.name}.ini", placeholder)

        # .env.example
        env_content = generate_env_example(system_config.mqtt)
        zf.writestr(".env.example", env_content)

        # README.md
        readme_content = generate_readme(system_config)
        zf.writestr("README.md", readme_content)

    return zip_buffer.getvalue()


def generate_placeholder_ini(cca: CCAConfig, mqtt: MQTTConfig) -> str:
    """Generate placeholder INI config when panels aren't known yet.

    This is used during initial setup before discovery completes.
    """
    # Generate placeholder modules from topology (strings * panel_count)
    modules = []
    for string in cca.strings:
        for i in range(1, string.panel_count + 1):
            # Use placeholder serial numbers
            modules.append(f"{string.name}:{i}:PLACEHOLDER_{string.name}{i}")

    modules_line = ",".join(modules)

    return f"""# TapTap-MQTT Configuration - {cca.name.title()} CCA
# Generated by Solar Tigo Viewer Setup Wizard
#
# NOTE: This is a PLACEHOLDER configuration.
# Serial numbers will need to be updated after discovery.
# Credentials are injected via environment variables at startup

[MQTT]
SERVER = ${{MQTT_SERVER}}
PORT = ${{MQTT_PORT}}
USER = ${{MQTT_USER}}
PASS = ${{MQTT_PASS}}
QOS = 1
TIMEOUT = 30

[TAPTAP]
LOG_LEVEL = info
BINARY = /usr/local/bin/taptap
SERIAL = {cca.serial_device}
ADDRESS =
PORT = 502
# PLACEHOLDER: Update MODULES with actual serial numbers after discovery
MODULES = {modules_line}
TOPIC_PREFIX = taptap
TOPIC_NAME = {cca.name}
TIMEOUT = 300
UPDATE = 5
STATE_FILE = /data/taptap.state

[HA]
DISCOVERY_PREFIX = homeassistant
DISCOVERY_LEGACY = false
BIRTH_TOPIC = homeassistant/status
NODES_AVAILABILITY_ONLINE = true
NODES_AVAILABILITY_IDENTIFIED = true
STRINGS_AVAILABILITY_ONLINE = true
STRINGS_AVAILABILITY_IDENTIFIED = true
STATS_AVAILABILITY_ONLINE = true
STATS_AVAILABILITY_IDENTIFIED = true
NODES_SENSORS_RECORDER = energy
STRINGS_SENSORS_RECORDER = energy_daily
STATS_SENSORS_RECORDER = energy_daily

[RUNTIME]
MAX_ERROR = 15
RUN_FILE = /run/taptap/taptap.run
"""
